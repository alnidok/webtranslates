<p>Одним из самых распространенных примеров использования SVG графики являются системы иконок. Для этого используется SVG элемент <code>&lt;use&gt;</code>, задающий экземпляры (копии) иконок. И при попытке стилизации этих экземпляров возникает куча ограничений. Целью данной статьи как раз является ознакомление с возможными способами обхода этих ограничений при использовании <code>&lt;use&gt;</code>.</p>
<!--more-->

<p>Но перед тем как начать, давайте пробежимся по основам SVG - это постепенно втянет нас в мир <code>use</code> и теневого DOM, а затем вернемся к CSS. Мы поймем, почему стилизация <code>&lt;use&gt;</code> является сложной и рассмотрим пути решения этой проблемы.</p>

<h2>Быстрый обзор структуры SVG, группировки и связывания (переиспользования) элементов в SVG.</h2>

<p>Существует 4 основных элемента, которые используются для определения, задания структуры и связей в SVG коде. Эти элементы делают переиспользование кода проще, сохраняя его чистым и читаемым.</p>

<p>Вот эти элементы: <code>&lt;g&gt;</code>, <code>&lt;defs&gt;</code>, <code>&lt;use&gt;</code> и <code>&lt;symbol&gt;</code>.</p>

<p>Элемент <code>&lt;g&gt;</code> (короткое от &quot;group&quot;) используется для логической группировки набора связанных графических элементов. С точки зрения графических редакторов, таких как Adobe Illustrator, элемент <code>&lt;g&gt;</code> имеет ту же функциональность, как и <em>Group Objects</em>. Можно также представлять группу как слой в графическом редакторе.</p>

<p>Группировка элементов полезна, когда мы хотим применить общий стиль, и особенно, если хотим анимировать группу элементов, сохраняя при этом их относительное расположение.</p>

<p>Элемент <code>&lt;defs&gt;</code> применяется для определения элементов, которые будут использоваться позднее. Определение элементов через <code>&lt;defs&gt;</code> полезно, когда вы хотите создать своего рода &quot;шаблон&quot;, который будет использоваться несколько раз в документе. Элементы, определенные внутри <code>&lt;defs&gt;</code> не отображаются, пока не будут &quot;вызваны&quot; где-то в документе.</p>

<p>Элемент <code>&lt;symbol&gt;</code> сочетает в себе преимущества и <code>&lt;defs&gt;</code> и <code>&lt;g&gt;</code>, т.к. может использоваться в качестве группировки элементов, определяющих шаблон, на который можно ссылаться из любого места документа. В отличие от <code>&lt;defs&gt;</code>, <code>&lt;symbol&gt;</code> как правило, не используются для определения шаблонов, а в основном используется, чтобы определить символы (например иконки), на которые имеются ссылки по всему документу.</p>

<p>Элемент <code>&lt;symbol&gt;</code> имеет важное преимущество: он принимает атрибут <code>viewBox</code>, который позволяет масштабироваться внутри любого вьюпорта, в котором происходит отрисовка.</p>

<p>Элемент <code>&lt;use&gt;</code> используется для ссылки на другие элементы, определенные где-то в документе. Он позволяет повторно использовать существующие элементы, давая вам возможность, аналогичную копированию-вставке в графическом редакторе. Он может применяться для переиспользования как отдельного элемента, так и группы, заданной через <code>&lt;g&gt;</code>, <code>&lt;defs&gt;</code> или <code>&lt;symbol&gt;</code>.</p>

<p>Для использования элемента передаем ссылку на него внутри <code>xlink:href</code> атрибута, а также устанавливаем <code>x</code> и <code>y</code>. Вы можете применять стили к <code>use</code>, и эти стили каскадно применятся к содержимому <code>use</code> элемента.</p>

<p>Но откуда берется содержимое <code>&lt;use&gt;</code>? Где происходит клонирование? И как CSS работает с этим содержимым?</p>

<p>Прежде чем отвечать на эти вопросы, стоит упомянуть несколько статей для лучшего понимания этих элементов и атрибута <code>viewBox</code>, который использует <code>&lt;symbol&gt;</code>:</p>

<ul>
    <li><a href="http://sarasoueidan.com/blog/structuring-grouping-referencing-in-svg/" target="_blank">Структурирование, группировка и привязка в SVG &mdash; элементы &lt;g&gt;, &lt;use&gt;, &lt;defs&gt; и &lt;symbol&gt;</a></li>
    <li><a href="http://sarasoueidan.com/blog/svg-coordinate-systems">Понимание координатной системы SVG (часть 1): viewport, viewBox и PreserveAspectRatio</a></li>
</ul>

<h2>SVG &lt;use&gt; и теневой DOM</h2>

<p>Когда мы ссылаемся на элемент с помощью <code>&lt;use&gt;</code>, код примерно такой:</p>

<pre>
<code class="language-html">&lt;symbol id="my-icon" viewBox="0 0 30 30"&gt;
    &lt;!-- icon content / shapes here --&gt;
    &lt;/symbol&gt;

    &lt;use xlink:href="#my-icon" x="100" y="300" /&gt;</code></pre>

<p>На экране отобразится иконка, которая определена внутри элемента <code>&lt;symbol&gt;</code>, но это скорее содержимое <code>&lt;use&gt;</code>, коротое является дубликатом содержимого <code>&lt;symbol&gt;</code>.</p>

<p>Но элемент <code>&lt;use&gt;</code> одиночный - внутри него нет никакого содержимого, но где тогда происходит дублирование содержимого <code>&lt;symbol&gt;</code>?</p>

<p>Ответ - <strong>теневой DOM</strong>.</p>

<h2>Что такое теневой DOM?</h2>

<p>Теневой DOM подобен обычному DOM за исключением того, что узлы (nodes) в теневом DOM принадлежат не основному дереву документа, а конкретному его фрагменту. Это дает программистам возможность инкапсуляции, задания скриптов и стилей при создании модульных компонентов. Если вы когда-то использовали HTML5 элемент <code>&lt;video&gt;</code> и задумывались, где спрятан код его элементов управления - значит вы уже сталкивались с теневым DOM.</p>

<p>В примере с <code>&lt;use&gt;</code>, контент связанного элемента дублируется во фрагмент документа, который располагается в <code>&lt;use&gt;</code>. В данном случае <code>&lt;use&gt;</code> называется теневым хостом (<em>Shadow Host</em>).</p>

<p>Итак, содержимое <code>&lt;use&gt;</code> (клон или копия любого ссылающегося элемента) присутствует в теневом фрагменте документа.</p>

<p>Другими словами, содержимое там есть, но его не видно. Оно такое же как и содержимое обычного DOM, но вместо того, чтобы быть доступно на высоком уровне (&quot;high-level&quot; DOM), оно копируется в определенный фрагмент документа в <code>&lt;use&gt;</code>.&nbsp;</p>

<p>Возможно сейчас вы задумались, можно ли увидеть эти скрытые части документа? Да, это возможно с помощью инструментов разработчика Chrome. (В Firefox пока нельзя). Итак, для того чтобы включить просмотр теневого DOM, нужно в основных настройках (вкладка General) активировать соответствующий флаг (Show user agent shadow DOM). Настройки открываются при клике по значку шестеренки. Подробнее об этом можно почитать <a href="http://oliversmith.io/technology/2012/05/19/inspecting-the-shadow-dom-in-google-chrome-inspector/" target="_blank">здесь</a>.</p>

<p>После того, как мы включили показ теневого DOM, на панели Elements можно увидеть дублированные элементы в виде обычных DOM элементов. На следующем изображении показан пример <code>&lt;use&gt;</code> элемента, ссылающегося на содержимое <code>&lt;symbol&gt;</code>. Обратите внимание на #shadow-root и его содержимое.</p>

<p>&nbsp;</p>

<figure><img alt="" src="http://codropspz.tympanus.netdna-cdn.com/codrops/wp-content/uploads/2015/07/shadow-dom.jpg">
    <figcaption>
        <p>С помошью инструментов разработчика Chrome, вы можете проинспектировать содержимое элемента &lt;use&gt; внутри теневого DOM.</p>
    </figcaption>
</figure>

<p>Глядя на этот код, вы можете убедиться, что теневой DOM очень похож на обычный DOM, за исключением разного поведения при обработке CSS и JavaScript из главного документа. Есть еще и другие отличия, но здесь о них говорить не будем, т.к. тема слишком обширная. Если хотите узнать больше об этом, рекомендую следующие статьи:</p>

<ul>
    <li><a href="http://code.tutsplus.com/tutorials/intro-to-shadow-dom--net-34966" target="_blank">Введение в теневой DOM</a></li>
    <li><a href="http://glazkov.com/2011/01/14/what-the-heck-is-shadow-dom/" target="_blank">Что за чертовщина этот теневой DOM?</a></li>
    <li><a href="http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom/" target="_blank">Теневой DOM 101</a></li>
    <li><a href="http://webcomponents.org/articles/introduction-to-shadow-dom/" target="_blank">Введение в теневой DOM</a> (видео)</li>
</ul>

<p>Лично я, учитывая насколько ограничены мои взаимодействия с теневым DOM, думаю о нем как об обычном DOM кроме случаев обработки стилей через CSS (и JavaScript).&nbsp;Вся суть элемента <code>&lt;use&gt;</code> заключается в возможности создания различных &quot;копий&quot; элемента, но во многих случаях нам нужно стилизовать каждую копию по-разному. Например представьте логотип в двух стилях (инвертированные цветовые темы), или разноцветные иконки, каждая из которых имеет свою цветовую тему. И конечно мы ожидаем, что сможем сделать это с помощью CSS.</p>

<p>Но как мы уже говорили ранее, содержимое теневого DOM нельзя стилизовать так же, как для обычного. Но тогда как нам быть? Мы не можем написать что-то вроде:</p>

<pre>
<code class="language-css css">use path#line {
    stroke: #009966;
    }</code></pre>

<p>потому что не имеем доступа обычных CSS селекторов к теневому DOM.</p>

<p>Есть <a href="http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom-201/#toc-style-cat-hat" target="_blank">несколько специальных селекторов</a>, которые позволяют &quot;проникнуть&quot; в теневой DOM, чтобы применить стили к узлам внутри него, но эти селекторы не только имеют <a href="http://caniuse.com/#feat=shadowdom" target="_blank">плохую поддержку</a>, но и очень ограничены по сравнению с обычными CSS селекторами. Кроме того, нам хочется более простого способа для стилизации содержимого <code>&lt;use&gt;</code> без необходимости &quot;пачкать руки&quot; в специфических особенностях теневого DOM. Мы просто хотим использовать CSS и SVG.&nbsp;</p>

<p>Чтобы этого добиться и получить немного больше контроля над процессом стилизации, мы должны думать под другим углом. И начнем с возможностей наследования в CSS.</p>

<h2>Каскадные стили</h2>

<p>В SVG элементы могут быть стилизованы тремя способами: внешние CSS стили (внешний файл), внутренние стили (элементы <code>&lt;style&gt;</code>) и встроенные стили (в виде атрибута <code>style</code>). Для нас имеет смысл то, как происходит применение стилей к элементам.</p>

<p>Помимо CSS свойств, SVG элементы можно стилизовать с помощью т.н. <em>атрибутов представления</em>. Атрибуты представления - это сокращенная запись задания CSS свойств элементу. Считайте их специальными стилевыми свойствами. По сути это то же самое, но менее ожидаемым образом.</p>

<p>В следующем куске кода, который просто отображает розовый круг с желтой обводкой, <code>stroke</code>, <code>stroke-width</code> и <code>fill</code> являются атрибутами предстваления.</p>

<pre>
<code class="language-html">&lt;svg viewBox="0 0 100 100"&gt;
    &lt;circle fill="deepPink" stroke="yellow" stroke-width="5" cx="50" cy="50" r="10"&gt;&lt;/circle&gt;
    &lt;/svg&gt;</code></pre>

<p>Множество всех CSS свойств может устанавличаться через SVG атрибутамы, и наоборот. Но не все CSS свойства могут быть указаны у SVG элемента как атрибуты представления и не все атрибуты представления, доступные в SVG, могут быть указаны через CSS.</p>

<p>Спецификация SVG перечисляет, <a href="http://www.w3.org/TR/SVG/propidx.html" target="_blank">какие SVG атрибуты могут быть установлены через CSS свойства</a>. Некоторые из этих атрибутов доступны как CSS свойства (например <code>opacity</code> и <code>transform</code>), а некоторые - нет (<code>fill</code>, <code>stroke</code>, <code>stroke-width</code>).</p>

<p>В SVG 2 этот список пополнился <code>x</code>, <code>y</code>, <code>width</code>, <code>height</code>, <code>cx</code>, <code>cy</code> и несколькими другими атрибутами представления, которые невозможно было установить через CSS в SVG 1.1. Новый список атрибутов <a href="http://www.w3.org/TR/SVG2/styling.html#SVGStylingProperties">в спецификации SVG 2</a>.</p>

<p>Если вы похожи на меня, то ожидаете, что у атрибутов представления больший приоритет, чем у других объявлений стилей. Я подразумеваю, что внешние стили переопределяются внутренними, внутренние - встроенными (inline). Т.о. наиболее &quot;внутренние&quot; стили имеют больший приоритет, и когда свойство указывается в атрибуте, оно более значимое и переопределяет все остальные объявления. Однако это не так.</p>

<p>На самом деле атрибуты представления имеют низкий приоритет, ниже внешних, внутренних и встроенных стилей. Они могут переопределить наследуемые элементом стили, и сами переопределяются любыми другими объявлениями стилей.</p>

<p>Отлично, теперь когда с этим все прояснилось, давайте вернемся к элементу <code>&lt;use&gt;</code> и его содержимому.</p>

<p>Теперь мы в курсе, что не можем задать стили внутри элемента <code>&lt;use&gt;</code> при помощи CSS селекторов. Также мы знаем, что стили, примененные к элементу <code>&lt;use&gt;</code>, будут унаследованы всеми его потомками (которые внутри теневого DOM).</p>

<p>Итак, первой попыткой изменить цвет заливки элемента внутри <code>&lt;use&gt;</code> будет применение этого стиля непосредственно на <code>&lt;use&gt;</code> и пусть наследование делает свое дело.</p>

<p>Однако это вызовет две проблемы:</p>

<ol>
    <li>Цвет заливки будет наследоваться <em>всеми</em> потомками <code>&lt;use&gt;</code>, даже теми, которые не нужно стилиизовать. (Если внутри <code>&lt;use&gt;</code> только один элемент, то это не проблема)</li>
    <li>Если вы экспортируете SVG из графического редактора или получили его от дизайнера, и по какой-то причине не можете отредактировать SVG код, вероятно вы остановитесь на атрибутах представления, которые в свою очередь переопределят любые стили, применяемые к <code>&lt;use&gt;</code>. И если вы определяете стили на <code>&lt;use&gt;</code>, вы хотите, чтобы они были унаследованы всеми потомками, т.о. атрибуты представления вызвали бы неудобство.</li>
</ol>

<p>И даже если у вас есть доступ к коду SVG и вы можете избавиться от атрибутов представления, <strong>настоятельно рекомендую этого не делать</strong>, потому что:</p>

<ol>
    <li>Удаление атрибутов, используемых для установки определенных свойств, сбросит эти свойства в значения браузера по умолчанию - в большинстве случаев это черная заливка и обводка (если говорить о цвете)</li>
    <li>Сбрасывая все значения, вы вынуждаете себя определять стили для всего набора свойств.</li>
    <li>Первоначально доступные атрибуты представления являются отличным механизмом запасного варианта, когда устанавливаемые вами внешние стили по какой-либо причине не применились. Если CSS файл не сможет подгрузиться, у вашей иконки по крайней мере будут хорошие стили по умолчанию. Я настоятельно рекомендую их сохранять.</li>
</ol>

<p>Хорошо, теперь у нас есть эти атрибуты, но предположим, что мы хотим стилизовать каждый экземпляр иконки по-разному.</p>

<p>Давайте начнем с простого примера, а затем перейдем к более сложным.</p>

<h2>Переопределение атрибутов представления через CSS</h2>

<p>Атрибуты представления переопределяются другими объявленными стилями. Мы можем этим воспользоваться, чтобы внешние стили переопределяли свойства наследуемых значений элемента <code>&lt;use&gt;</code>.</p>

<p>Используя <a href="http://tympanus.net/codrops/css_reference/inherit" target="_blank">ключевое слово inherit</a> в CSS, можно сделать это довольно просто. Посмотрите на следующий пример, в котором имеется иконка мороженого, сделанная с помощью одной линии. Автор иконки Erin Agnolu из <a href="http://thenounproject.com" target="_blank">проекта Noun</a>. Пусть мы хотим изменить цвет единственной линии для разных экземпляров. </p>

<pre>
<code class="language-html">&lt;svg&gt;
    &lt;symbol id="ic"&gt;
    &lt;path fill="#000" d="M81,40.933c0-4.25-3-7.811-6.996-8.673c-0.922-5.312-3.588-10.178-7.623-13.844  c-2.459-2.239-5.326-3.913-8.408-4.981c-0.797-3.676-4.066-6.437-7.979-6.437c-3.908,0-7.184,2.764-7.979,6.442  c-3.078,1.065-5.939,2.741-8.396,4.977c-4.035,3.666-6.701,8.531-7.623,13.844C22.002,33.123,19,36.682,19,40.933  c0,2.617,1.145,4.965,2.957,6.589c0.047,0.195,0.119,0.389,0.225,0.568l26.004,43.873c0.383,0.646,1.072,1.04,1.824,1.04  c0.748,0,1.439-0.395,1.824-1.04L77.82,48.089c0.105-0.179,0.178-0.373,0.225-0.568C79.855,45.897,81,43.549,81,40.933z   M49.994,11.235c2.164,0,3.928,1.762,3.928,3.93c0,2.165-1.764,3.929-3.928,3.929s-3.928-1.764-3.928-3.929  C46.066,12.997,47.83,11.235,49.994,11.235z M27.842,36.301c0.014,0,0.027,0,0.031,0c1.086,0,1.998-0.817,2.115-1.907  c0.762-7.592,5.641-13.791,12.303-16.535c1.119,3.184,4.146,5.475,7.703,5.475c3.561,0,6.588-2.293,7.707-5.48  c6.664,2.742,11.547,8.944,12.312,16.54c0.115,1.092,1.037,1.929,2.143,1.907c2.541,0.013,4.604,2.087,4.604,4.631  c0,1.684-0.914,3.148-2.266,3.958H25.508c-1.354-0.809-2.268-2.273-2.268-3.958C23.24,38.389,25.303,36.316,27.842,36.301z   M50.01,86.723L27.73,49.13h44.541L50.01,86.723z"/&gt;
    &lt;/symbol&gt;
    &lt;/svg&gt;</code></pre>

<p>Содержание иконки (<code>path</code>) определяется внутри элемента <code>&lt;symbol&gt;</code>. Это означает, что они не будут отображаться на холсте.</p>

<p>Затем мы рендерим несколько экземпляров иконки с помощью <code>&lt;use&gt;</code>.</p>

<pre>
<code class="language-html">&lt;svg class="icon" viewBox="0 0 100 125"&gt;
    &lt;use class="ic-1" xlink:href="#ic" x="0" y="0" /&gt;
    &lt;/svg&gt;
    &lt;svg class="icon" viewBox="0 0 100 125"&gt;
    &lt;use class="ic-2" xlink:href="#ic" x="0" y="0" /&gt;
    &lt;/svg&gt;</code></pre>

<p>И устанавливаем ширину и высоту через CSS. Я использую такие же размеры как у <code>viewBox</code>, но они не обязательно должны быть такими же. Однако, чтобы избежать избытка пустого места внутри SVG, убедитесь, что пропорции сохранены.</p>

<pre>
<code class="language-css css">.icon {
    width: 100px;
    height: 125px;
    }</code></pre>

<p>В итоге получается следующее:</p>

<p><img alt="" src="http://codropspz.tympanus.netdna-cdn.com/codrops/wp-content/uploads/2015/07/Screen-Shot-2015-07-15-at-13.21.02.png"></p>

<p>Обратите внимание на черные границы, т.о. можно видеть границы каждого SVG и удостовериться, что в первом случае (где мы лишь определили иконку) ничего не рандерится. Итак, <strong>SVG документ все равно будет отображаться на странице, даже если в нем нечего показывать</strong>. Чтобы этого избежать, скрываем первый SVG (<code>display: none</code>). Если этот элемент не скрывать, по умолчанию он будет показываться на странице с размерами 300x150px, так что в итоге вы получите белую область на странице.</p>

<p>Теперь попробуем изменить цвет заливки для разных экземпляров:</p>

<pre>
<code class="language-css css">use.ic-1 {
    fill: skyblue;
    }
    use.ic-2 {
    fill: #FDC646;
    }</code></pre>

<p>Цвет все еще не изменился, т.к. он наследуется от элемента path (<code>fill=&quot;#000&quot;</code>). Поэтому для <code>path</code> наследуем цвет заливки:</p>

<pre>
<code class="language-css css">svg path {
    fill: inherit;
    }</code></pre>

<p>И вуаля! Теперь цвет, указанный для каждого <code>&lt;use&gt;</code>, применяется для <code>path</code>. Посмотрите демо, поиграйтесь с цветами, создайте больше экземпляров:</p>

<p><iframe allowfullscreen="true" allowtransparency="true" class="cp_embed_iframe undefined" frameborder="0" height="300" id="cp_embed_f15cec4a61e753259bd768de2e20500b" scrolling="no" src="//codepen.io/SaraSoueidan/embed/f15cec4a61e753259bd768de2e20500b?height=300&amp;theme-id=0&amp;border=thin&amp;border-color=%230099CC&amp;tab-bar-color=%230099CC&amp;tab-link-color=%23ffffff&amp;active-tab-color=%23056495&amp;active-link-color=%23ffffff&amp;slug-hash=f15cec4a61e753259bd768de2e20500b&amp;default-tab=result&amp;user=SaraSoueidan" style="width: 100%; overflow: hidden;"></iframe></p>

<p>Эта техника полезна, когда нужно применить внутри <code>&lt;use&gt;</code> наследуемые от главного элемента стили. Но в большинстве случаев требуется не совсем то. Поэтому перейдем к другим примерам.</p>

<h2>Стилизация соедержимого &lt;use&gt; с помощью CSS свойства all</h2>

<p>Некоторое время назад я работала над иконкой, на которую ссылалась через <code>&lt;use&gt;</code>, и хотела, чтобы один из элементов внутри наследовал все стили (<code>fill</code>, <code>stroke</code>, <code>stroke-fill</code>, <code>opacity</code> и даже <code>transform</code>) от <code>&lt;use&gt;</code>. В общем я хотела управлять всеми этими атрибуатми из CSS, при этом оставляя атрибуты представления в разметке как запасной вариант.</p>

<p>Оказавшись в такой же ситуации, вы вероятно напишете в CSS:</p>

<pre>
<code class="language-css css">path#myPath {
    fill: inherit;
    stroke: inherit;
    stroke-width: inherit;
    transform: inherit;
    /* ... */
    }</code></pre>

<p>Видно, что нужно устанавливать все свойства в <code>inherit</code>. К счастью, нас выручит CSS свойство <code>all</code>. Я уже писала о нем <a href="http://tympanus.net/codrops/css_reference/all/" target="_blank">в заметке</a>, но стоит еще раз упомянуть в данном контексте.</p>

<p>Используя свойство <code>all</code>, мы можем переписать код следующим образом:</p>

<pre>
<code class="language-css css">path#myPath {
    all: inherit;
    }</code></pre>

<p>Это отлично работает во всех браузерах, которые поддерживают данное свойство (посмотрите упомянутую заметку), однако есть важное замечание: <strong>это объявление установит буквально все свойства в значение inherit</strong>, даже те, которые вам не хочется. Поэтому применять all - это лишь чрезвычайная мера, особенно полезная, если вы хотите &quot;заложить основу&quot; элемента и можете управлять свойствами через CSS. Если вы будете использовать такое объявление, не определив конкретные значения для всех свойств в CSS, они каскадно будут искать родительские значение, и в большинстве случаев применят стили браузера по умолчанию.</p>

<p>Обратите внимание, что это затронет атрибуты, которые могут быть установлены через CSS, не SVG атрибуты. Т.о. если атрибут может быть установлен через CSS, он будет искать значение родителя, а иначе - не будет.</p>

<p>Мы в состоянии заставить атрибуты представления наследоваться от стилей элемента <code>&lt;use&gt;</code>. Но что если наша иконка содержит несколько элементов, и мы не хотим, чтобы все элементы наследовали свойства от <code>&lt;use&gt;</code>? Что делать, если мы хотим применить разные цвета для разных элементов внутри <code>&lt;use&gt;</code>? Установка одного стиля к <code>use</code> больше не поможет, нужно что-то еще, чтобы помочь нам задать нужные цвета нужным элементам...</p>

<h2>Использование CSS-переменной currentColor для стилизации содержимого &lt;use&gt;</h2>

<p>Использовуя <a href="http://tympanus.net/codrops/css_reference/color_value/#section_currentColor" target="_blank">CSS-переменную currentColor</a> в сочетании с описанной техникой, можно указать два разных цвета на элементе вместо одного. Fabrice Weinberg <a href="http://codepen.io/FWeinb/blog/quick-tip-svg-use-style-two-colors" target="_blank">описал этот способ в своем Codepen блоге</a> около года назад.</p>

<p>Идея заключается в том, чтобы применить к <code>&lt;use&gt;</code> оба свойства (<code>fill</code> и <code>color</code>). Давайте сразу перейдем к примеру кода, чтобы увидеть как это работает.</p>

<p>Предположим, что мы хотим стилизовать простой логотип Codrops, используя два цвета - один для передней капельки, второй для задней - и сделаем несколько экземпляров.</p>

<p><img alt="" src="http://codropspz.tympanus.netdna-cdn.com/codrops/wp-content/uploads/2015/07/StylingSVGuse_codropsdrops.png"></p>

<p>Для начала сделаем разметку для этого примера: должен быть <code>&lt;symbol&gt;</code>, содержащий определение нашей иконки и 3 экземпляра <code>&lt;use&gt;</code>.</p>

<pre>
<code class="language-html">&lt;svg style="display: none;"&gt;
    &lt;symbol id="codrops" viewBox="0 0 23 30"&gt;
    &lt;path class="back" fill="#aaa" d="M22.63,18.261c-0.398-3.044-2.608-6.61-4.072-9.359c-1.74-3.271-3.492-5.994-5.089-8.62l0,0   c-1.599,2.623-3.75,6.117-5.487,9.385c0.391,0.718,0.495,1.011,0.889,1.816c0.143,0.294,0.535,1.111,0.696,1.43   c0.062-0.114,0.582-1.052,0.643-1.162c0.278-0.506,0.54-0.981,0.791-1.451c0.823-1.547,1.649-2.971,2.469-4.33   c0.817,1.359,1.646,2.783,2.468,4.33c0.249,0.47,0.513,0.946,0.791,1.453c1.203,2.187,2.698,4.906,2.96,6.895   c0.292,2.237-0.259,4.312-1.556,5.839c-1.171,1.376-2.824,2.179-4.663,2.263c-1.841-0.084-3.493-0.887-4.665-2.263   c-0.16-0.192-0.311-0.391-0.448-0.599c-0.543,0.221-1.127,0.346-1.735,0.365c-0.56-0.019-1.095-0.127-1.599-0.313   c1.448,3.406,4.667,5.66,8.447,5.78C19.086,29.537,23.469,24.645,22.63,18.261z"/&gt;
    &lt;path class="front" fill="#ddd" d="M6.177,11.659c0.212,0.367,0.424,0.747,0.635,1.136c0.164,0.303,0.333,0.606,0.512,0.927   c0.683,1.225,1.618,2.898,1.755,3.937c0.144,1.073-0.111,2.056-0.716,2.769c-0.543,0.641-1.315,1.014-2.186,1.067   c-0.87-0.054-1.643-0.43-2.186-1.067c-0.604-0.713-0.858-1.695-0.715-2.771c0.137-1.036,1.072-2.712,1.755-3.936   c0.18-0.32,0.349-0.623,0.513-0.927C5.752,12.404,5.964,12.026,6.177,11.659 M6.177,5.966L6.177,5.966   c-1.02,1.649-2.138,3.363-3.247,5.419c-0.932,1.728-2.344,3.967-2.598,5.88c-0.535,4.014,2.261,7.09,5.846,7.203   c3.583-0.113,6.379-3.189,5.845-7.203c-0.255-1.912-1.666-4.152-2.598-5.88C8.314,9.329,7.196,7.617,6.177,5.966L6.177,5.966z"/&gt;
    &lt;/symbol&gt;
    &lt;/svg&gt;
    &lt;svg height="90px" width="69px"&gt;
    &lt;use xlink:href="#codrops" class="codrops-1"/&gt;
    &lt;/svg&gt;
    &lt;svg height="90px" width="69px"&gt;
    &lt;use xlink:href="#codrops" class="codrops-2"/&gt;
    &lt;/svg&gt;
    &lt;svg height="90px" width="69px"&gt;
    &lt;use xlink:href="#codrops" class="codrops-3"/&gt;
    &lt;/svg&gt;</code></pre>

<p>Если мы установим <code>fill</code> на элемент <code>&lt;use&gt;</code>, этот цвет будет применяться к обоим <code>path</code>, и получатся две одноцветные капельки - это не то, чего мы хотим.</p>

<p>Здесь мы будем использовать <code>currentColor</code> для разделения цветов. Вставляем <code>currentColor</code> в том месте, где хотим применить другой цвет. Это должно быть в определении нашей иконки, т.е. внутри элемента <code>&lt;symbol&gt;</code>. Получаем следующий код:</p>

<pre>
<code class="language-html">&lt;svg style="display: none;"&gt;
    &lt;symbol id="codrops" viewBox="0 0 23 30"&gt;
    &lt;path class="back" fill="#aaa" d="..."/&gt;
    &lt;path class="front" fill="currentColor" d="..."/&gt;
    &lt;/symbol&gt;
    &lt;/svg&gt;</code></pre>

<p>Далее мы должны удалить атрибут представления <code>fill</code> для второй капельки, позволив применить цвет заливки <code>use</code>, без использования техники наследования.</p>

<p>Если мы будем использовать ключевое слово <code>inherit</code> для того, чтобы атрибуты представления унаследовали свои значения от <code>&lt;use&gt;</code>, тогда оба <code>path</code> будут иметь одинаковые значения цвета, и мы не увидим никакого эффекта от использования <code>currentColor</code>. В нашем случае нужно удалить атрибут, который хотим устанавливать через CSS, и оставить только один path со значением <code>fill=&quot;currentColor&quot;</code>.</p>

<pre>
<code class="language-html">&lt;svg style="display: none;"&gt;
    &lt;symbol id="codrops" viewBox="0 0 23 30"&gt;
    &lt;path class="back" d="..."/&gt;
    &lt;path class="front" fill="currentColor" d="..."/&gt;
    &lt;/symbol&gt;
    &lt;/svg&gt;</code></pre>

<p>Теперь, используя свойства <code>fill</code> и <code>color</code>, мы можем стилизовать капельки:</p>

<pre>
<code class="language-css css">.codrops-1 {
    fill: #4BC0A5;
    color: #A4DFD1;
    }
    .codrops-2 {
    fill: #0099CC;
    color: #7FCBE5;
    }
    .codrops-3 {
    fill: #5F5EC0;
    color: #AEAFDD;
    }</code></pre>

<p>Каждый элемент <code>&lt;use&gt;</code> получает свои значения <code>fill</code> и <code>color</code>. Для каждого цвет <code>fill</code> наследуется от первого <code>path</code>, который не имеет атрибута <code>fill</code>, и значение свойства color используется в качестве атрибута <code>fill</code> для второго <code>path</code>.</p>

<p>Вот результат:</p>

<p><iframe allowfullscreen="true" allowtransparency="true" class="cp_embed_iframe undefined" frameborder="0" height="300" id="cp_embed_9cb698c206c6b572264f9b0509b0156f" scrolling="no" src="//codepen.io/SaraSoueidan/embed/9cb698c206c6b572264f9b0509b0156f?height=300&amp;theme-id=0&amp;border=thin&amp;border-color=%230099CC&amp;tab-bar-color=%230099CC&amp;tab-link-color=%23ffffff&amp;active-tab-color=%23056495&amp;active-link-color=%23ffffff&amp;slug-hash=9cb698c206c6b572264f9b0509b0156f&amp;default-tab=result&amp;user=SaraSoueidan" style="width: 100%; overflow: hidden;"></iframe></p>

<p>Эта двухцветная техника весьма полезна для простых двухцветных логотипов. В своей статье Fabrice делает три разных варианта логотипа Sass, изменяя цвет текста и цвет фона.</p>

<p>На сегодня <code>currentColor</code> - это единственная доступная переменная в CSS. Однако, если бы у нас было больше переменных, мы бы смогли передать больше значений в содержимое <code>&lt;use&gt;</code>. Amelia Bellamy-Royds представляла эту концепцию <a href="http://codepen.io/AmeliaBR/thoughts/customizable-svg-icons-css-variables" target="_blank">в записи своего Codepen блога</a> около года назад. Давайте посмотрим, как это работает.</p>

<h2>Будущее: стилизация содержимого &lt;use&gt; с помощью кастомных CSS свойств (CSS переменных)</h2>

<p>Используя <a href="http://www.w3.org/TR/css-variables/" target="_blank">собственные CSS свойства (CSS переменные)</a>, вы можете стилизовать содержимое <code>&lt;use&gt;</code> без необходимости переопределения значений атрибутов представления.</p>

<p>Как <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_variables" target="_blank">сказано в MDN</a>, CSS переменные - это объекты, определяемые авторами или пользователями на веб страницах для того, чтобы хранить определенные значения всюду в документе. Они устанавливаются, используя кастомные свойства и для получаения доступа используется <code>var()</code>. Они очень похожи на переменные CSS препроцессоров (типа Sass), но более гибкие и <a href="http://www.sitepoint.com/css-variables-can-preprocessors-cant/" target="_blank">могут делать вещи, которые переменные препроцессора не умеют</a>.</p>

<p>У переменных, будь то CSS переменные или переменные препроцессора, есть много примеров использования, но именно изменение цветов является наиболее распространенным примером. И здесь мы рассмотрим, как это может быть применено для SVG.</p>

<p>Мы рассмотрим одно изображение, определенное в <code>&lt;symbol&gt;</code> и один элемент <code>&lt;use&gt;</code>, однако все описанное может быть применено и для множества элементов <code>&lt;use&gt;</code>.</p>

<p>Предположим, у нас есть иллюстрация милого робота-хипстера (<a href="http://www.freepik.com/free-vector/cute-vector-hipster-robot-character_714905.htm" target="_blank">от Freepik</a>).</p>

<p><img alt="" src="http://codropspz.tympanus.netdna-cdn.com/codrops/wp-content/uploads/2015/07/Screen-Shot-2015-07-15-at-22.32.43.png"></p>

<p>Код разметки для этого робота такой:</p>

<pre>
<code class="language-html">&lt;svg style="display: none"&gt;
    &lt;symbol id="robot" viewBox="0 0 340 536"&gt;
    &lt;path d="..." fill="#fff" /&gt;
    &lt;path d="..." fill="#D1312C" /&gt;
    &lt;path d="..." fill="#1E8F90" /&gt;
    &lt;path d="..." fill="#1E8F90" /&gt;
    &lt;path d="..." fill="#fff" /&gt;
    &lt;path d="..." fill="#6A4933" /&gt;
    &lt;path d="..." fill="#1E8F90"  /&gt;
    &lt;path d="..." fill="#6A4933" /&gt;
    &lt;path d="..." fill="#fff" /&gt;
    &lt;path d="..." fill="#6A4933" /&gt;
    &lt;path d="..." fill="#F2B42B" /&gt;
    &lt;path d="..." fill="#fff" /&gt;

    &lt;!-- rest of the shapes --&gt;
    &lt;/symbol&gt;
    &lt;/svg&gt;</code></pre>

<p>Мы не собираемся использовать CSS переменные как значения <code>fill</code> для каждого path; вместо этого, мы собираемся задать значение <code>fill</code> через CSS, и при этом храним атрибуты <code>fill</code> в разметке. <strong>Эти атрибуты будут использованы в качестве запасного варианта для браузеров, не поддерживающих CSS переменные.</strong> Поэтому в таких браузерах изображение будет показываться с первоначальными цветами.</p>

<p>С добавлением переменных, получается такой код:</p>

<pre>
<code class="language-html">&lt;svg style="display: none"&gt;
    &lt;symbol id="robot" viewBox="0 0 340 536"&gt;
    &lt;path d="..." fill="#fff" /&gt;
    &lt;path d="..." fill="#D1312C" /&gt;
    &lt;path d="..." fill="#1E8F90" style="fill: var(--primary-color)" /&gt;
    &lt;path d="..." fill="#1E8F90" style="fill: var(--primary-color)" /&gt;
    &lt;path d="..." fill="#fff" /&gt;
    &lt;path d="..." fill="#6A4933" style="fill: var(--tertiary-color)" /&gt;
    &lt;path d="..." fill="#1E8F90" style="fill: var(--primary-color)" /&gt;
    &lt;path d="..." fill="#6A4933" style="fill: var(--tertiary-color)" /&gt;
    &lt;path d="..." fill="#fff" /&gt;
    &lt;path d="..." fill="#6A4933" style="fill: var(--tertiary-color)" /&gt;
    &lt;path d="..." fill="#F2B42B" style="fill: var(--secondary-color)" /&gt;
    &lt;path d="..." fill="#fff" /&gt;

    &lt;!-- rest of the shapes --&gt;
    &lt;/symbol&gt;
    &lt;/svg&gt;</code></pre>

<p>Т.к. встроенные стили переопределяют атрибуты представления, браузеры, поддерживающие CSS переменные, будут использовать эти переменные в качестве цвета заливки. А браузеры, не имеющие поддержки CSS переменных, будут вместо этого использовать значение атрибута <code>fill</code>.</p>

<p>Далее мы должны определить значения переменных в CSS. Для начала покажем изобрачение с помощью <code>&lt;use&gt;</code>:</p>

<pre>
<code class="language-html">&lt;svg width="340" height="536"&gt;
    &lt;use xlink:href="#robot" id="robot-1" /&gt;
    &lt;/svg&gt;</code></pre>

<p>Затем переменные должны быть определены на элементе <code>&lt;use&gt;</code>, чтобы они каскадом перешли в его содержимое. Цвета, которые мы выберем для переменных, составят цветовую схему нашей иллюстрации. Для робота имелось три основных цвета: которые я назову primary, secondary и tertiary.</p>

<pre>
<code class="language-css css">#robot-1 {
    --primary-color: #0099CC;
    --secondary-color: #FFDF34;
    --tertiary-color: #333;
    }</code></pre>

<p>После применения вышеупомянутых цветов для переменных, получается немного другой робот:</p>

<p><img alt="" src="http://codropspz.tympanus.netdna-cdn.com/codrops/wp-content/uploads/2015/07/Screen-Shot-2015-07-15-at-22.54.53.png"></p>

<p>Вы можете сделать много экземпляров, поиграться с цветами и реализовать несколько тем.</p>

<p>Мы упомянули, что браузеры, не поддерживающие CSS переменные, в качестве запасного варианта используют стили из атрибутов представления; браузеры, имеющие поддержку, будут использовать именно переменные вместо атрибутов. Отлично. Но что произойдет, если браузер поддерживает CSS переменные, но автор забывает указать значение переменной, или указано неверное значение?</p>

<p>Для нашего робота мы определили 3 переменные, и несколько элементов осталось без определения. Если мы запустим текущий код в браузере, который поддерживает CSS переменные (в настоящее время только Firefox), и удалите объявление переменной из CSS, вот что получится:</p>

<p><img alt="" src="http://codropspz.tympanus.netdna-cdn.com/codrops/wp-content/uploads/2015/07/Screen-Shot-2015-07-15-at-22.59.37.png"></p>

<p>Если значения переменных не установлены или они неверные, браузер будет использовать цвета по умолчанию, и обычно это черный цвет для заливки и обводки в SVG.</p>

<p>Способом избежать этого является указание <strong>других &quot;запасных&quot; цветов для браузеров</strong>. Синтаксис CSS переменных подразумевает использование &quot;запасных&quot; цветов. Они указываются в <code>var()</code> вторым аргументом. Т.о. код изменится:</p>

<pre>
<code class="language-html">&lt;svg style="display: none"&gt;
    &lt;symbol id="robot" viewBox="0 0 340 536"&gt;
    &lt;path d="..." fill="#fff" /&gt;
    &lt;path d="..." fill="#D1312C" /&gt;
    &lt;path d="..." fill="#1E8F90" style="fill: var(--primary-color, #1E8F90)" /&gt;
    &lt;path d="..." fill="#1E8F90" style="fill: var(--primary-color, #1E8F90)" /&gt;
    &lt;path d="..." fill="#fff" /&gt;
    &lt;path d="..." fill="#6A4933" style="fill: var(--tertiary-color, #6A4933)" /&gt;
    &lt;path d="..." fill="#1E8F90" style="fill: var(--primary-color, #1E8F90)" /&gt;
    &lt;path d="..." fill="#6A4933" style="fill: var(--tertiary-color, #6A4933)" /&gt;
    &lt;path d="..." fill="#fff" /&gt;
    &lt;path d="..." fill="#6A4933" style="fill: var(--tertiary-color, #6A4933)" /&gt;
    &lt;path d="..." fill="#F2B42B" style="fill: var(--secondary-color, #F2B42B)" /&gt;
    &lt;path d="..." fill="#fff" /&gt;

    &lt;!-- rest of the shapes --&gt;
    &lt;/symbol&gt;
    &lt;/svg&gt;</code></pre>

<p>Вот и все. Для любой переменной, которой не удается найти установленное значение, браузер применит запасной цвет, указанный в разметке. Замечательно.</p>

<p>Используя эту технику, вы можете ссылаться на робота из любого места на странице с помощью элемента <code>&lt;use&gt;</code>, и для каждого нового экземпляра задавать цвета через CSS, тем самым создавая различные цветовые темы.</p>

<p>Можете поиграться с демо, создать несколько экземпляров робота, менять значение переменных. Но только удостоверьтесь, что используете Firefox, потому что это пока что единственный браузер, который поддерживает CSS переменные.</p>

<p><iframe allowfullscreen="true" allowtransparency="true" class="cp_embed_iframe undefined" frameborder="0" height="650" id="cp_embed_c30e270090b2460ba6e6833c611e5a76" scrolling="no" src="//codepen.io/SaraSoueidan/embed/c30e270090b2460ba6e6833c611e5a76?height=650&amp;theme-id=0&amp;border=thin&amp;border-color=%230099CC&amp;tab-bar-color=%230099CC&amp;tab-link-color=%23ffffff&amp;active-tab-color=%23056495&amp;active-link-color=%23ffffff&amp;slug-hash=c30e270090b2460ba6e6833c611e5a76&amp;default-tab=result&amp;user=SaraSoueidan" style="width: 100%; overflow: hidden;"></iframe></p>

<p>Если вы смотрите демо в Firefox, то должны видеть синюю + желтую версию робота, как определяется в CSS переменных. Если смотрите в Chrome - зеленую версию, вступает в игру запасной вариант. Попробуйте также удалить объявление CSS переменных и посмотреть, как работает запасной вариант в Firefox.</p>

<h2>Заключение</h2>

<p>Уф. Многовато получилось.</p>

<p>Используя преимущества CSS каскадирования, стилизация содержимого <code>&lt;use&gt;</code> (в теневом DOM) может стать проще. А с помощью CSS переменных (будь то единственный <code>currentColor</code> или кастомные переменные) мы можем проникнуть внутрь теневого DOM и кастомизировать графику так, как нам захочется, при этом обеспечивая хороший запасной вариант, когда что-то пойдет не так.</p>

<p>Лично я невероятно поражена связкой CSS переменные + SVG. Мне нравятся их возможности, при том что имеется отличный запасной механизм. <strong>Как уже говорилось ранее, пока поддержка реализована только в Firefox, но мы можем добиться более широкой поддержки браузерами, например проголосовав <a href="https://wpdev.uservoice.com/forums/257854-internet-explorer-platform/suggestions/6261292-css-variables" target="_blank">на форуме MS Edge</a>.</strong></p>

<p>В будущем мы даже можем получить другие способы стилизации содержимого <code>&lt;use&gt;</code>, уже есть <a href="https://lists.w3.org/Archives/Public/www-svg/2014Nov/0000.html" target="_blank">дискуссии</a> по поводу использования CSS переменных а качестве SVG параметров. Т.о. хотя эта статья оказалась длинной, все же не затронула все, что нужно знать по этой теме.</p>

<p>Инспектирование содержимого <code>&lt;use&gt;</code> элементов было одним из частых вопросов, вызывающих недопонимание. На эту тему существует много статей, но здесь не об этом.</p>

<p>Надеюсь статья вам понравилась и вы нашли что-то полезное для себя.</p>

<p>Спасибо за прочтение!</p>